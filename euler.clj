                                        ;14. Which starting number, under one million, produces the longest chain?
                                        ;=====================================================================
if don't have recorded then recurse with node added to stack and the next step

(def *chains* {1 '(1)})

(defn p14-chain-step [x]
  (if (even? x)
    (/ x 2)
    (inc (* 3 x))))

(defn record-new-chains [sub-chain new-nodes]
  "Store all new chains that can be generated by adding new-nodes to existing sub-chain and return the longest"
  (cond
   (empty? new-nodes) sub-chain
   :else 
   (reduce
    #(let [next-chain (cons %2 %)]
       (def *chains* (assoc *chains* %2 next-chain))
       next-chain)
    sub-chain
    new-nodes)))

(defn chain [x]
  (loop [node x, new-nodes ()]
    (cond
     (contains? *chains* node) (record-new-chains (get *chains* node) new-nodes)
     :else
     (let [next-node (p14-chain-step node)]
       (recur next-node (conj new-nodes node))))))

(defn longest-chain-to [x]
  (reduce
   #(if (> (second %2) (second %)) %2 %)
   [0 0]
   (map
    #(vector (first %) (count (second %)))
    (for [y (range 1 x)] [y (chain y)]))))

                                        ;16. What is the sum of the digits of the number 2^1000?
                                        ;=======================================================
(defn clj-pow [base power]
  (loop [mult base, iters power, total 1]
    (cond
     (zero? iters) total
     :else (recur mult (dec iters) (* total base)))))

(defn sum-digits [x]
  (loop [x x, sum 0]
    (cond
     (zero? x) sum
     :else (let [r (rem x 10), q (quot x 10)]
             (recur q (+ sum r))))))

                                        ;17. How many letters would be needed to write all the numbers in words from 1 to 1000?
                                        ;======================================================================================
(def *up-to-10* ["one" "two" "three" "four" "five" "six" "seven" "eight" "nine"])
(def *up-to-20* ["ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"])
(def *tens* ["twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"])
(def *trio-names* ["thousand" "million" "billion" "trillian"])

(def *letters* (into #{} "abcdefghijklmnopqrstuvwxyz"))

(defn chunk-in-words [x]
  "Convert an integer 0 < x < 1,000 into words"
  (let 
      [units (mod x 10)
       tens (mod quot x 10) 10)
    hundreds (mod (quot x 100) 10)
    hundreds-text (if (zero? hundreds) "" (str (*up-to-10* (dec hundreds)) " hundred"))
    tens-text (if (>= tens 2) (*tens* (- tens 2)) "")
    units-ish-text 
    (cond
     (< tens 1) (if (zero? units) "" (*up-to-10* (dec units)))
     (< tens 2) (*up-to-20* units)
     :else (if (zero? units) "" (*up-to-10* (dec units))))]
  (str
   hundreds-text
   (if (and (not (= hundreds-text "")) (or (not (= tens-text "")) (not (= units-ish-text "")))) " and " "")
   tens-text
   (if (and (> tens 1) (> units 0)) "-")
   units-ish-text
   )))

(defn in-words [x]
  (let
      [chunk1 (mod x 1000)
       rest-chunks (quot x 1000)]
    (apply str
           (interpose ", " (filter
                            #(not= % "")
                            (concat
                             (loop [y rest-chunks, trio 0, acc ()] ; Get a list of the text for each chunk
                               (cond
                                (zero? y) acc
                                :else 
                                (let 
                                    [trio-value-in-words (chunk-in-words (mod y 1000))
                                     trio-name (*trio-names* trio)
                                     trio-in-words (if (= trio-name "") trio-value-in-words (str trio-value-in-words " " trio-name))]
                                  (recur (quot y 1000) (inc trio) (cons trio-in-words acc)))))
                             (let [chunk1-words (chunk-in-words chunk1)]
                               (list (if (and (> rest-chunks 0) (< 0 chunk1 100)) (str "and " chunk1-words) chunk1-words)))))))))

(defn letters-in-number-in-words [x]
  (reduce
   #(if (contains? *letters* %2) (inc %) %)
   0
   (in-words x)))

(println (apply + (map letters-in-number-in-words (range 1 1001))))

                                        ;18 (& 67). Find the maximum total from top to bottom of the triangle
                                        ;==============================================================
(defn largest-sum-through-triangle [lines]
  (let
      [reversed-lines (reverse lines)]
    (loop [largest-line (first reversed-lines), remaining-lines (rest reversed-lines)]
      (cond
       (empty? remaining-lines) (max largest-line)
       :else
       (let
           [next-line (first remaining-lines)
            rest-lines (rest remaining-lines)
            mapped-line 
            (map
             #(+ % (max (first %2) (second %2)))
             next-line
             (partition 2 1 largest-line))]
         (recur mapped-line rest-lines))))))

(largest-sum-through-triangle 
 ['(75)
  '(95 64)
  '(17 47 82)
  '(18 35 87 10)
  '(20 4 82 47 65)
  '(19 1 23 75 3 34)
  '(88 2 77 73 7 63 67)
  '(99 65 4 28 6 16 70 92)
  '(41 41 26 56 83 40 80 70 33)
  '(41 48 72 33 47 32 37 16 94 29)
  '(53 71 44 65 25 43 91 52 97 51 14)
  '(70 11 33 28 77 73 17 78 39 68 17 57)
  '(91 71 52 38 17 14 91 43 58 50 27 29 48)
  '(63 66 4 68 89 53 67 30 73 16 69 87 40 31)

  '(4 62 98 27 23 9 70 98 73 93 38 53 60 4 23)])

(largest-sum-through-triangle 
 [])

                                        ;19. How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
                                        ;===============================================================================================================
(defn days-in-month [year month]
  (cond
   (#{4 6 9 11} (inc month)) 30
   (#{1 3 5 7 8 9 10 12} (inc month)) 31
   (zero? (mod year 400)) 29
   (zero? (mod year 100)) 28
   (zero? (mod year 4)) 29
   :else 28))

(defn first-in-next-month-weekday [{:keys [year month weekday]}]
  "Returns map of next year (zero-based) month and (zero-based Monday) weekday"
  (let 
      [days-in-cur-month (days-in-month year month)
       next-weekday (mod (+ weekday days-in-cur-month) 7)
       next-month (mod (inc month) 12)
       next-year (+ (if (= next-month 0) 1 0) year)]
    (hash-map :year next-year :month next-month :weekday next-weekday)))

(defn first-in-months [m]
  (let [next-first (first-in-next-month-weekday m)]
    (lazy-seq (cons m (first-in-months next-first)))))

(count (filter #(not= (% :weekday) 6) (take-while #(< (% :year) 2001) (filter #(> (% :year) 1900) (first-in-months {:year 1900 :month 0 :weekday 0})))))

                                        ;20. Find the sum of the digits in the number 100!
                                        ;=================================================
(defn fct [x]
  (loop [y x, acc 1]
    (cond
     (= y 1) acc
     :else (recur (dec y) (* acc y)))))

(sum-digits (fct 100M))

                                        ;21. Evaluate the sum of all the amicable numbers under 10000
                                        ;============================================================
                                        ;To avoid repeated calculations, looking at generating vector of sum of proper factors
(defn proper-factors [x] (disj (factors x) x))

(defn proper-factors-sum-to [x]
  (for [y (range 1 x)] [y (apply + (proper-factors y))]))

(defn amicable-numbers-sum-to [x]
  (let [pfst (into [] (proper-factors-sum-to x))]
    (apply +
           (map
            #(+ (first %) (second %))
            (filter
             #(and
               (< (first %) (second %))
               (< (second %) x)
               (= (first %) (second (get pfst (dec (second %))))))
             pfst)))))

                                        ;22. What is the total of all the name scores in the file?
                                        ;=========================================================
(println (into [] (.split (String/replace read-line "\"" "")) ","))



                                        ;23. Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
==========================================================================================================
(defn abundant? [x]
  (> (apply + (proper-factors x)) x))

(defn abundant-to [x]
  (filter abundant? (range x)))

(into #{} 
      (let [at (bundant-to 28123)]
        (for [x at, y at :while (<= y x)] (+ x y))))

                                        ;24. What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
===================================================================================================

(defn fct [x]
  (loop [y x, acc 1]
    (cond
     (< y 2) acc
     :else (recur (dec y) (* acc y)))))

(defn nth-lexicographic [chars n]
  "Returns the nth item from a lecixographic ordering of chars."
  (loop [chars (sort chars) n (dec n) s ""]
    (cond
     (empty? chars) s
     :else
     (let [first-char-loop (fct (dec (count chars)))
           first-char-index (quot n first-char-loop)
           first-char (nth chars first-char-index)
           second-char-steps (mod n first-char-loop)]
       (recur (filter #(not= first-char %) chars) second-char-steps (str s first-char))))))
